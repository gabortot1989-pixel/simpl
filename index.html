<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SimplAir‑EC — Three.js (Netlify v8, Click‑to‑Add)</title>
  <style>
    :root{ --bg:#0b0e14; --text:#e6e9ef}
    html,body{height:100%;margin:0;background:#0b0e14;color:var(--text);font:14px system-ui,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
    header{display:flex;gap:10px;align-items:center;padding:10px 12px}
    header h1{font-size:16px;margin:0}
    #viewer{position:relative}
    canvas{display:block;cursor:default}
    .panel{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-start;padding:10px 12px;background:#0e1219;border-top:1px solid #131a26}
    .group{display:flex;flex-direction:column;gap:8px;background:#0f141c;padding:10px;border-radius:10px;border:1px solid #1f2937;min-width:320px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    select,button{background:#0e1420;color:#d5dde8;border:1px solid #223;padding:6px 8px;border-radius:8px;cursor:pointer}
    #hud{position:absolute;top:10px;right:10px;background:#14213a;border:1px solid #26416b;color:#dbeafe;padding:8px;border-radius:10px;font-size:12px;white-space:pre;max-width:72ch}
    #err{position:absolute;bottom:10px;right:10px;background:#3a1414;border:1px solid #6b2626;color:#ffd6d6;padding:8px;border-radius:10px;font-size:12px;white-space:pre;max-width:60ch;display:none}
    ul{margin:0;padding-left:18px;max-height:160px;overflow:auto}
    .pick{background:#123;border-color:#2a6;box-shadow:0 0 0 2px #2a6 inset}
  </style>
  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.152.2/build/three.module.js" } }
  </script>
</head>
<body>
<div id="app">
  <header>
    <h1>SimplAir‑EC — Three.js</h1><span style="opacity:.7">Netlify v8 • Click‑to‑Add</span>
  </header>
  <div id="viewer">
    <div id="hud">Betöltés…</div>
    <div id="err"></div>
  </div>
  <div class="panel">
    <div class="group">
      <div class="row">
        <label>EV</label>
        <select id="selEV"><option value="1" selected>1</option><option value="0">0</option><option value="3">3</option><option value="6">6</option></select>
        <label>AV</label>
        <select id="selAV"><option value="15" selected>15</option><option value="0">0</option><option value="6">6</option><option value="10">10</option></select>
        <label>L1</label>
        <select id="selL1"><option value="30">30</option><option value="20">20</option><option value="40">40</option><option value="100" selected>100</option></select>
        <label>L1+L2</label>
        <select id="selL12"><option value="60">60</option><option value="30">30</option><option value="80">80</option><option value="100" selected>100</option></select>
      </div>
      <div class="row">
        <button id="btnApply">Kombináció alkalmazása</button>
        <button id="btnHoriz">Vízszintes</button>
        <button id="btnUpright">Álló</button>
        <button id="btnFocusDip">Fókusz DIP</button>
        <button id="btnTest">Teszt Dip‑1 ON/OFF</button>
      </div>
    </div>

    <div class="group">
      <div class="row">
        <label>DIP debug</label>
        <select id="selDipIdx"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option></select>
        <button id="btnSwapOne">Csoport csere (kijelölt)</button>
        <button id="btnSwapAll">Csoport csere (mind)</button>
        <button id="btnSolo">Csak ez látszódjon</button>
        <button id="btnUnsolo">Összes vissza</button>
      </div>
      <div class="row">
        <button id="btnPickOn">Hozzáadás kattintással [ON]</button>
        <button id="btnPickOff">Hozzáadás kattintással [OFF]</button>
        <button id="btnPickCancel">Kijelölés mód KI</button>
      </div>
      <div id="meshListWrap">
        <div style="opacity:.7">Állapot szerinti besorolás ezen a DIP-en:</div>
        <ul id="meshList"></ul>
      </div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import {OrbitControls} from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';

const hud = document.getElementById('hud');
const err = document.getElementById('err');
const viewer = document.getElementById('viewer');

// Scene
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight - 200);
renderer.outputColorSpace = THREE.SRGBColorSpace;
viewer.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101316);
const camera = new THREE.PerspectiveCamera(45, renderer.domElement.width/renderer.domElement.height, 0.1, 200);
camera.position.set(2.2, 1.6, 2.2);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,5,6); scene.add(dir);

function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
animate();
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight - 200);
  camera.aspect = renderer.domElement.width/renderer.domElement.height;
  camera.updateProjectionMatrix();
});

// Load GLB
const loader = new GLTFLoader();
const candidates = [
  'SimplAir-EC.glb',
  new URL('SimplAir-EC.glb', location.href).toString(),
  new URL('./SimplAir-EC.glb', location.href).toString(),
  new URL('/SimplAir-EC.glb', location.origin).toString()
];

let root=null;
let dips=new Map(); // idx -> {group, meshes:[mesh...], baseZ:[...], onGroup:Set, offGroup:Set, invert:boolean, on:true}
const ON_RAD = Math.PI*35/180;

function normName(n){ return (n||'').toLowerCase().replace(/[\s \u00A0]+/g,''); }

function collectMeshes(node){
  const arr=[];
  node.traverse(n=>{ if(n.isMesh) arr.push(n); });
  return arr;
}

function loadNext(i=0){
  if(i>=candidates.length){ fail('Nem sikerült betölteni a GLB-t.'); return; }
  const url = candidates[i];
  hud.textContent = 'Betöltés…\\n' + url;
  loader.load(url, (gltf)=>{
    root = gltf.scene; scene.add(root);
    setupAfterLoad();
  }, (xhr)=>{
    hud.textContent = xhr.total ? `Betöltés: ${(xhr.loaded/xhr.total*100).toFixed(0)}%\\n${url}` : `Betöltés: ${xhr.loaded} B\\n${url}`;
  }, (e)=>{ console.warn('GLB betöltési hiba:', e); loadNext(i+1); });
}

function setupAfterLoad(){
  dips.clear();
  root.rotation.x = -Math.PI/2;
  const info=[];
  root.traverse(n=>{
    const nm = normName(n.name);
    const m = nm.match(/^dip[-_]?(\d)$/i);
    if(m){
      const idx = parseInt(m[1],10);
      const parts = collectMeshes(n);
      const baseZ = parts.map(p=>p.rotation.z);
      const minZ = Math.min(...baseZ), maxZ = Math.max(...baseZ);
      const mid = (minZ + maxZ)/2;
      const onGroup = new Set(), offGroup = new Set();
      parts.forEach((p,i)=>{ (baseZ[i] >= mid ? onGroup : offGroup).add(p); });
      dips.set(idx, {group:n, meshes:parts, baseZ, onGroup, offGroup, invert:false, on:true});
      info.push(`Dip-${idx}: ${parts.length} mesh | ON: ${onGroup.size}, OFF: ${offGroup.size}`);
    }
  });
  // fit view
  const box = new THREE.Box3().setFromObject(root);
  const size = box.getSize(new THREE.Vector3()).length();
  const center = box.getCenter(new THREE.Vector3());
  controls.target.copy(center);
  camera.near = size/100; camera.far = size*10; camera.updateProjectionMatrix();
  const dist = size*0.9;
  camera.position.copy(center.clone().add(new THREE.Vector3(dist, dist*0.6, dist)));
  controls.update();
  hud.textContent = `Betöltve.\n${info.join('\\n')}`;
  // Alaphelyzet: ON csoport látszik
  dips.forEach(d=>{
    d.meshes.forEach((m,i)=>{
      const isOnMesh  = d.onGroup.has(m);
      const isOffMesh = d.offGroup.has(m);
      m.visible = isOnMesh;
      if(isOnMesh) m.rotation.z = d.baseZ[i];
      if(isOffMesh) m.rotation.z = d.baseZ[i] - ON_RAD;
    });
  });
  refreshDebugList();
}

function fail(message){ err.style.display='block'; err.textContent = message; }

function visibleByState(d, isOn, m){
  const onSets = d.invert ? d.offGroup : d.onGroup;
  const offSets = d.invert ? d.onGroup : d.offGroup;
  return isOn ? onSets.has(m) : offSets.has(m);
}

function setDip(idx, isOn){
  const d = dips.get(idx); if(!d) return;
  d.meshes.forEach((m,i)=>{
    m.visible = visibleByState(d, isOn, m);
    const isOnMesh  = (d.invert ? d.offGroup : d.onGroup).has(m);
    const isOffMesh = (d.invert ? d.onGroup : d.offGroup).has(m);
    if(isOnMesh)  m.rotation.z = d.baseZ[i];
    if(isOffMesh) m.rotation.z = d.baseZ[i] - ON_RAD;
    m.updateMatrixWorld(true);
  });
  d.on = isOn;
}

function compute(evv,avv,l1,l12){
  let S1=false,S2=false;
  if(evv===1){ /*00*/ } else if(evv===0){ S2=true } else if(evv===3){ S1=true } else if(evv===6){ S1=true; S2=true }
  let S3=false,S4=false;
  if(avv===15){ /*00*/ } else if(avv===0){ S4=true } else if(avv===6){ S3=true } else if(avv===10){ S3=true; S4=true }
  let S5=false,S6=false;
  if(l1===30){ /*00*/ } else if(l1===20){ S6=true } else if(l1===40){ S5=true } else if(l1===100){ S5=true; S6=true }
  let S7=false,S8=false;
  if(l12===60){ /*00*/ } else if(l12===30){ S8=true } else if(l12===80){ S7=true } else if(l12===100){ S7=true; S8=true }
  return [S1,S2,S3,S4,S5,S6,S7,S8];
}

function applyCombo(){
  const evv = parseInt(document.getElementById('selEV').value,10);
  const avv = parseInt(document.getElementById('selAV').value,10);
  const l1  = parseInt(document.getElementById('selL1').value,10);
  const l12 = parseInt(document.getElementById('selL12').value,10);
  const st = compute(evv,avv,l1,l12);
  for(let i=0;i<8;i++) setDip(i+1, st[i]);
  hud.textContent = `EV:${evv} AV:${avv} L1:${l1} L1+L2:${l12}\\nTarget: ${st.map(v=>v?1:0).join('')}`;
}
['selEV','selAV','selL1','selL12'].forEach(id=> document.getElementById(id).addEventListener('change', applyCombo));
document.getElementById('btnApply').onclick = applyCombo;

// Debug UI: swap groups, solo, pick-to-add
function refreshDebugList(){
  const ul = document.getElementById('meshList');
  ul.innerHTML='';
  const idx = parseInt(document.getElementById('selDipIdx').value,10);
  const d = dips.get(idx); if(!d) return;
  d.meshes.forEach((m,i)=>{
    const tag = (d.invert ? d.offGroup : d.onGroup).has(m) ? '[ON]' : '[OFF]';
    const li=document.createElement('li');
    li.textContent = `${tag} ${m.name || m.parent?.name || m.type}`;
    ul.appendChild(li);
  });
}
document.getElementById('selDipIdx').addEventListener('change', refreshDebugList);

document.getElementById('btnSwapOne').onclick = ()=>{
  const idx = parseInt(document.getElementById('selDipIdx').value,10);
  const d = dips.get(idx); if(!d) return;
  d.invert = !d.invert; setDip(idx, d.on); refreshDebugList();
  hud.textContent = `Dip-${idx}: ON/OFF csoport csere: ${d.invert?'INVERTED':'NORMAL'}`;
};
document.getElementById('btnSwapAll').onclick = ()=>{
  dips.forEach((d,idx)=>{ d.invert = !d.invert; setDip(idx, d.on); });
  refreshDebugList();
  hud.textContent = 'Mind a 8 DIP: ON/OFF csoport csere végrehajtva.';
};
document.getElementById('btnSolo').onclick = ()=>{
  const idx = parseInt(document.getElementById('selDipIdx').value,10);
  const d = dips.get(idx); if(!d) return;
  const keep = new Set(d.meshes.map(x=>x.id));
  root.traverse(n=>{ if(n.isMesh) n.visible = keep.has(n.id); });
};
document.getElementById('btnUnsolo').onclick = ()=>{ root.traverse(n=>{ if(n.isMesh) n.visible = true; }); };

// Picking
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let pickMode = null; // 'on' | 'off' | null
function setPickMode(mode){
  pickMode = mode;
  renderer.domElement.classList.toggle('pick', !!mode);
  hud.textContent = mode ? `Kattints egy mesh-re, hozzáadás: ${mode.toUpperCase()}` : 'Kijelölés mód KI';
}
document.getElementById('btnPickOn').onclick = ()=> setPickMode('on');
document.getElementById('btnPickOff').onclick = ()=> setPickMode('off');
document.getElementById('btnPickCancel').onclick = ()=> setPickMode(null);

renderer.domElement.addEventListener('pointerdown', (e)=>{
  if(!pickMode) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
  mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(root, true);
  if(intersects.length === 0) return;
  const mesh = intersects[0].object;
  const idx = parseInt(document.getElementById('selDipIdx').value,10);
  const d = dips.get(idx); if(!d) return;
  if(!d.meshes.includes(mesh)){ d.meshes.push(mesh); d.baseZ.push(mesh.rotation.z); }
  if(pickMode === 'on'){ d.onGroup.add(mesh); d.offGroup.delete(mesh); }
  if(pickMode === 'off'){ d.offGroup.add(mesh); d.onGroup.delete(mesh); }
  setDip(idx, d.on);
  refreshDebugList();
  hud.textContent = `Dip-${idx}: hozzáadva → ${pickMode.toUpperCase()} : ${mesh.name || mesh.parent?.name || mesh.type}`;
}, false);

document.getElementById('btnHoriz').onclick = ()=>{ if(root){ root.rotation.x = -Math.PI/2; } };
document.getElementById('btnUpright').onclick = ()=>{ if(root){ root.rotation.x = 0; } };
document.getElementById('btnFocusDip').onclick = ()=>{
  if(!root) return;
  const idx = parseInt(document.getElementById('selDipIdx').value,10);
  const target = dips.get(idx)?.group || dips.get(1)?.group;
  if(!target) return;
  const box = new THREE.Box3().setFromObject(target.parent || target);
  const center = box.getCenter(new THREE.Vector3());
  controls.target.copy(center);
  camera.position.copy(center.clone().add(new THREE.Vector3(0.25,0.15,0.35)));
  controls.update();
};

document.getElementById('btnTest').onclick = ()=>{ const d = dips.get(1); if(!d) return; setDip(1, !d.on); };

loadNext();
setTimeout(applyCombo, 1400);
</script>
</body>
</html>
